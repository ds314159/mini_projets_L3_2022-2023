"0",""
"0","alpha = 0.05"
"0","model = lmod_2"
"0",""
"0",""
"0","# Fixer le nombre de tirages :"
"0","nbr_tirages = 4000"
"0","# Garder le même résultat si réexecution de la chunk"
"0","set.seed(123)"
"0","# Créer la matrice qui contiendra les coeffs Beta de chaque itération"
"0","p = length(model$coefficients)"
"0","matrice_coeffs = matrix(NA, nbr_tirages, p)"
"0","colnames(matrice_coeffs) = names(model$coefficients)"
"0",""
"0","# récupérer les residuals et les fitted"
"0","residuals = residuals(model)"
"0","fitted = fitted(model)"
"0",""
"0","# Réaliser les tirages avec remise et remplir la matrice des coeffs"
"0","for(i in 1:nbr_tirages){"
"0","  "
"0","  booty = fitted + sample(residuals,  rep=TRUE)"
"0","  model_i = update(model, booty ~ .)"
"0","  matrice_coeffs[i,]= coef(model_i)"
"0","  "
"0","}"
"0"," # Obtenir l'intervalle de confiance pour chaque predicteur"
"0","CIs = apply(matrice_coeffs, 2, function(x) quantile(x, c((alpha/2), 1-(alpha/2))))"
"0",""
"0",""
"0","CIS = t(CIs)"
"0","CIS = cbind(CIS, coefficients(lmod_2))"
"0","colnames(CIS)[1] = ""seuil 2.5% """
"0","colnames(CIS)[2] = ""seuil 97.5%"""
"0","colnames(CIS)[3] = ""valeur modele"""
"0","kable(CIS)"
